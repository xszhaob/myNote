对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。

序列化新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。

POJO类必须写toString方法。使用工具类source>generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。

类内方法定义顺序依次是：公有方法或保护方法>私有方法>getter/setter方法。公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。


final可提高程序响应效率。

任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。

Map/Set的key为自定义对象时，必须重写hashCode和equals。

合理利用好集合的有序性（sort）和稳定性（order），避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。稳定性指每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则依次排列的。如ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。

利用Set元素唯一的特性，可以快速对另一个集合进行去重操作，避免使用List的contains方法进行遍历去重操作。

获取单例对象要线程安全。在单例对象里面做操作也要保证线程安全。

线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

SimpleDataFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。

高并发时，同步调用应考量锁的性能消耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。

对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。

并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。

多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务便会自动终止运行，使用ScheduleExecutorService则没有这个问题。

方法中需要进行参数校验的场景：
	1）调用频次低的方法。 
	2）执行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。 
	3）需要极高稳定性和可用性的方法。4）对外提供的开放接口，不管是RPC/API/HTTP接口。
方法中不需要参数校验的场景：
	1）极有可能被循环调用的方法；
	2）底层的方法，底层的方法调用频率较高，一般在顶层做校验；
	3）private方法一般只有自己调用，如果能够确保参数没有问题，可以不校验。