


第九章：单元测试
	9.1 TDD三大定律：
	定律一 在编写不能通过的单元测试前，不可编写生产代码。
	定律二 只可编写刚好无法通过的单元测试，不能编译也算不通过。
	定律三 只可编写刚好足以通过当前失败测试的生产代码。
	9.2 保持测试代码整洁
	测试代码和生产代码一样重要。他可不是二等公民。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。
	测试越脏，就越难修改。测试代码越缠结，你就越有可能花更多时间塞进新测试，而不是编写新生产代码。修改生产代码后，旧测试就会开始失败，而测试代码中乱七八糟的东西将阻碍代码再次通过。
	测试代码越脏，代码就会变得越脏。
	9.3 整洁的测试代码
	整洁的测试代码有三要素：可读性，可读性和可读性。和其他代码一样：明确，简洁，还有足够的表达力。
	每个测试都要清晰地拆为三个环节。第一个环节构造测试数据，第二个环节操作测试数据，第三个环节检验操作是否得到期望的效果。
	9.4 每个测试方法一个断言
	最好的测试是单个测试中的断言数量应该是最小化。
	9.5 F.I.R.S.T
	快速(Fast) 测试代码应该运行的足够快。
	独立(Independent) 测试应该相互独立。某个测试不应为下个测试设定条件。
	可重复(Repeatable) 测试应当可在任何环境中重复通过。
	自足验证(Self-Validating) 测试应该有布尔值输出。无论是否通过测试，你不应该查看日志文件来确认测试是否通过。
	及时(Timely) 测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。
	对于项目的健康度，测试代码同等重要。或许测试更重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。所以，必须要保持测试代码的整洁。让测试代码具有表达力并短小精悍。
第十章：类
	10.1 类的组织
	遵循标准的Java约定，类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。
	公共函数应跟在变量列表之后。推荐把由某个公共函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则，让程序读起来就想一篇报纸文章。
	关于封装，我们首先会想办法保持变量和工具函数的私有性。放松封装总是下策。
	10.2 类应该短小
	对于函数，我们通过计算代码行数衡量大小。对于类，我们采用不同的衡量方法，计算权责(responsibility)。
	类的名称应当描述其权责。实际上，命名正是帮助判断类的长度的第一个手段。如果无法为某个类命以精确的名称，这个类大概就太长了。类名越含混，该类就越有可能拥有过多权责。
		10.2.1 单一权责原则
		单一权责原则认为，类或模块应该有且只有一条加以修改的理由。
		每个达到一定规模的系统都会包括大量逻辑和复杂性。管理这种复杂性的首要目标就是加以组织，以便开发者知道到哪儿找到东西，并且在某个特定时间只需要理解直接有关的复杂性。反之，拥有巨大、多目的类的系统，总是让我们在目前并不需要了解的一大堆东西中艰难跋涉。
		再强调一下：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与其他类一起协同达成期望的系统行为。
		10.2.2 内聚
		如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。一般来说，创建这种极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。内聚性高，意味着类中的方法和变量相互依赖、相互结合成一个逻辑整体。
	10.3 为了修改而组织
	对于大多数系统，修改将一直持续。每处修改都让我们冒着系统其它部分不能如期望般工作的风险。在整洁的系统中，我们对类加以组织，以降低修改的风险。
	我们希望将系统打造成在添加或修改特性时尽可能少惹麻烦的架子。在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。